        -:    0:Source:PFD.c++
        -:    0:Graph:PFD.gcno
        -:    0:Data:PFD.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:
        -:    2:
        -:    3:// --------
        -:    4:// includes
        -:    5:// --------
        -:    6:
        -:    7:#include <cassert>  // assert
        -:    8:#include <iostream> // endl, istream, ostream
        -:    9:#include <vector>
        -:   10:#include <queue>
        -:   11:#include <algorithm> //for_each
        -:   12:#include <cstdio> //for NULL
        -:   13:
        -:   14:#include "PFD.h"
        -:   15:
        -:   16:using namespace std;
        -:   17:
function _Z9solve_PFDRSiRSo called 6 returned 100% blocks executed 71%
        6:   18:  void solve_PFD(istream& r, ostream& w)
        -:   19:{
        6:   20:    assert(r != NULL);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        6:   21:    assert(w != NULL);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        -:   22:
        -:   23:    int task_size, rules_size;
        6:   24:    r >> task_size;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        6:   25:    r >> rules_size;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:   26:
        6:   27:    assert(task_size > 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        6:   28:    assert(task_size <= 100);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        6:   29:    assert(rules_size >= 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:   30:   // assert(rules_size < task_size);
        -:   31:
        -:   32:    //create a vector of Verticses, each vertex represents a task
        6:   33:    vector<Vertex> vertices(task_size);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
        -:   34:    //assign the corresponding number the Vertices represent
       33:   35:    for(int i = 0, j = 1; i < (int)vertices.size(); ++i, ++j)
call    0 returned 100%
branch  1 taken 82%
branch  2 taken 18% (fallthrough)
        -:   36:    {
       27:   37:        vertices[i].num = j;
call    0 returned 100%
        -:   38:    }
        -:   39:
        6:   40:    read_rules(r, rules_size, vertices);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:   41:
        6:   42:    eval_PFD(vertices, w);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
call    4 never executed
        6:   43:}
call    0 never executed
function _Z10read_rulesRSiiRSt6vectorI6VertexSaIS1_EE called 6 returned 100% blocks executed 71%
        6:   44: void read_rules(istream& r, int rules_size, vector<Vertex>& vertices)
        -:   45:{
        6:   46:    assert(r != NULL);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        6:   47:    assert(rules_size >= 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        6:   48:    assert(rules_size < 100);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        6:   49:    assert(!vertices.empty());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        6:   50:    assert(vertices.size() <= 100);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:   51:
       25:   52:    while(rules_size-- != 0)
branch  0 taken 68%
branch  1 taken 32% (fallthrough)
        -:   53:    {
       13:   54:        read_rule(r, vertices);
call    0 returned 100%
        -:   55:    }
        6:   56:}
        -:   57:
function _Z9read_ruleRSiRSt6vectorI6VertexSaIS1_EE called 13 returned 100% blocks executed 73%
       13:   58: void read_rule(istream& r, vector<Vertex>& vertices)
        -:   59:{
       13:   60:    assert(r != NULL);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
       13:   61:    assert(!vertices.empty());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
       13:   62:    assert(vertices.size() <= 100);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:   63:
        -:   64:    int index, predecessors_size, predecessor;
        -:   65:
       13:   66:    r >> index;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       13:   67:    r >> predecessors_size;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:   68:
       13:   69:    assert(index > 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
       13:   70:    assert(index <= 100);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
       13:   71:    assert(predecessors_size >= 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
       13:   72:    assert(predecessors_size < 100);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:   73:
       13:   74:    vertices[index-1].num_pre = predecessors_size;
call    0 returned 100%
        -:   75:
       44:   76:    while(predecessors_size-- != 0)
branch  0 taken 58%
branch  1 taken 42% (fallthrough)
        -:   77:    {
       18:   78:        r >> predecessor;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       18:   79:        vertices[predecessor-1].succeeders.push_back(&vertices[index-1]);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
        -:   80:    }
       13:   81:}
        -:   82:
function _Z6solvedRSt6vectorI6VertexSaIS0_EE called 6 returned 100% blocks executed 80%
        6:   83:inline bool solved(vector<Vertex>& vertices)
        -:   84:{
        6:   85:    assert(!vertices.empty());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        6:   86:    assert(vertices.size() <= 100);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:   87:
       33:   88:    for(int i = 0; i < (int)vertices.size(); ++i)
call    0 returned 100%
branch  1 taken 82%
branch  2 taken 18% (fallthrough)
        -:   89:    {
       27:   90:        if(vertices[i].num_pre != 0)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:   91:        {
    #####:   92:            return false;
        -:   93:        }
        -:   94:    }
        6:   95:    return true;
        -:   96:}
        -:   97:
function _Z8eval_PFDRSt6vectorI6VertexSaIS0_EERSo called 6 returned 100% blocks executed 73%
        6:   98: void eval_PFD (vector<Vertex>& vertices, ostream& w)
        -:   99:{
        6:  100:    assert(w != NULL);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        6:  101:    assert(!vertices.empty());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        6:  102:    assert(vertices.size() <= 100);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:  103:
        -:  104:    //priority queue for verticses with no predecessors (cache)
        6:  105:    priority_queue<Vertex*, vector<Vertex*>, Comp_q> vertices_no_p;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 never executed
        -:  106:
        -:  107:    //push the Vertices with no predecessors to the cache
        6:  108:    for_each(vertices.begin(), vertices.end(), Transfer_vertices(&vertices_no_p));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        -:  109:    
        6:  110:    assert(!vertices_no_p.empty()); //the problem is solvable
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:  111:
        -:  112:    int vertex;
        -:  113:    vector<Vertex*>* succeeders;
       39:  114:    while(!vertices_no_p.empty()) //print task with no predecessor one by one
call    0 returned 100%
branch  1 taken 82%
branch  2 taken 18% (fallthrough)
        -:  115:    {
       27:  116:        vertex = vertices_no_p.top()->num;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       27:  117:        succeeders = &(vertices_no_p.top()->succeeders);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  118:        
       27:  119:        print_vertex(w, vertex);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  120:        
       27:  121:        vertices_no_p.pop();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  122:
        -:  123:        //decreases the number of predecessors of all succeeders by 1 and push it to the queue of vertices with no predecessors if number of predecessors reach 0
       27:  124:        for_each(succeeders->begin(), succeeders->end(), Remove_predecessors(&vertices_no_p));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        -:  125:    }
        -:  126:
        6:  127:    assert(solved(vertices)); //all tasks have been displayed (test if all tasks have no predecessor)
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
call    6 returned 100%
call    7 never executed
        6:  128:}
        -:  129:
function _Z12print_vertexRSoi called 27 returned 100% blocks executed 71%
       27:  130: void print_vertex (ostream& w, int i) 
        -:  131:{
       27:  132:    assert(i > 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
       27:  133:    assert(i <= 100);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
       27:  134:    w << i << " ";
call    0 returned 100%
call    1 returned 100%
function _GLOBAL__sub_I__Z9solve_PFDRSiRSo called 1 returned 100% blocks executed 100%
function _Z41__static_initialization_and_destruction_0ii called 1 returned 100% blocks executed 100%
       30:  135:}
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
        -:  136:
